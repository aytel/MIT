\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 

\begin{document}
\def\t{\texttt}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
    \setlength{\parskip}{0pt} 
    \setlength{\itemsep}{0pt} 
    \item Если все клозы содержат больше одной переменной, то просто выдадим всем переменным true и получим успех. Иначе выполним все клозы, 
    состоящие только из одного отрицательного литерала -- если после этого какой-то из оставшихся будет невыполним, то мы проиграли, иначе 
    снова выдадим всем оставшимся true. Работает за линию. \\
    \item Отсортируем числа по возрастанию и заведём переменную p = 0, которая значит "какой префикс умеем набирать". Переберём числа. Пусть 
    текущее = b. Если b $>$ p + 1, то ответ -- p + 1. Иначе p += b. В конце если нигде не сломались, то ответ p + 1.\\
    \item ~\\
    a) Если веса на рёбрах, то XOR пути a-b равен XOR'у путей ROOT-a и ROOT-b $\to$ обойдём дерево dfs-ом и будет пихать в хэшмап ксоры на путях 
    от корня до вершины и проверять, есть ли в хэшмапе путь с ксором S XOR cur, где cur -- текущий ксор. Работает за линию вообще. \\
    b) Делаем центроидную декомпозицию $\to$ задачу можно заменить на "найти проходящий через корень путь" $\to$ тоже пихаем величины в хэшмап. \\
    Чтобы памяти было O(n), достаточно после каждого обхода центроидной компоненты чистить этот хэшмап. \\
    \item ~\\
    b) Делаем центроиду, сводим задачу на "сколько проходящих через корень путей". Пусть сейчас мы обходим какое-то поддерево корня и находимся в 
    вершине на глубине d. Тогда нас интересуют все вершины из предыдущих поддеревьев корня на глубинах от L - d до R - d. Давайте заведём специальный 
    массив cnt[i] = кол-во вершин на глубине не больше i среди всех обойдённых поддеревьев. Тогда нам нужен запрос суммы на отрезке -- это одно вычитание 
    префиксных сумм. \\
    Когда мы обойдём поддерево, этот массив надо будет обновить -- причём полностью, ведь это префиксные суммы. Давайте тогда обходить поддеревья в 
    порядке увеличения глубины, тогда после каждого мы будем проводить модификацию за O(размер поддерева). \\
    \item ~\\
    a) precalc -- построим центроиду, запомним расстояние до каждого нашего центроидного предка. Когда красим вершину v в чёрный, то обновляем ответ 
    для неё и всех её предков p величиной d[v][p]. Когда запрос для вершины v, то перебираем предка p и выбираем минимум среди dist[v][p] + ans[p]. \\
    b) Теперь надо ещё и красить вершины обратно -- обновлением ответа для предка будет не просто релаксация величиной d[v][p], а запихнём эту величину в кучу, 
    а потом будем её лениво удалять, если нас покрасили обратно. \\
\end{enumerate}

\section{Дополнительные задачи}

\begin{enumerate}
    \setlength{\parskip}{0pt} 
    \setlength{\itemsep}{0pt} 
    \item ~\\
    \item ~\\
    \item ~\\
    a) Построим MST. \\
    b) Найдём кратчайший путь. \\
    c) В любом дереве, содержащего эти вершины, найдётся одна такая, что пути в дереве от неё до этих трёх сойдутся в ней $\to$ запустим 
    три Дейкстры и найдём v с минимальной величиной d[a][v] + d[b][v] + d[c][v]. \\
\end{enumerate}

\end{document}
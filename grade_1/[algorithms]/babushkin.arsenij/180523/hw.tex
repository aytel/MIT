\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 

\begin{document}
\def\t{\texttt}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item Сортим рёбра по весу, идём двумя указателями. Хотим добавить новое ребро (v, u) -- чекаем в ETT is\_connected(v, u). Пока да, двигаем l, 
    удаляя рёбра. \\
    \item Из каждой не листовой вершины мы продолжим вниз вертикальный путь в ровно одну вершину -- зачем не продолжать, если можно продолжать? Надо узнать, в 
    какую. А надо в ту, в которую идёт больше всего путей. Узнать, в каком поддереве больше всего концов путей, можно как угодно. Например, переливайкой. Это всё 
    оптимально, потому что на вершине v смена путей будет ровно у тех запросов, которые уходят через v вниз, но не в ту вершину, в которую мы продолжим путь. Значит, 
    надо продолжить именно туда, куда идёт больше всего запросов. \\
    \item ~\\
    \item Первый рекурсивный вызов работает за F(n/8, m/2), второй -- за F(n/8, n/8 + U), U $\le$ m/2, $\to$ он работает за F(n/8, n/8 + m/2). Скажем, что первый тоже работает 
    за F(n/8, n/8 + m/2), тогда F(n, m) $\le$ n + m + 2F(n/8, n/8 + m/2). Докажем, что F(n, m) $\le$ min($n^2$, $m\log n$) по индукции. База вроде очевидная с точностью до константы, дальше: \\
    F(n, m) $\ge$ 2F(n/8, n/8 + m/2) $\ge$ 2min($n^2$/64, (n/8 + m/2)$\log(n/8)$ $\ge$ min($n^2$/32, m$\log n$). чтд. \\
\end{enumerate}

\section{Дополнительные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item ~\\
    \item link, видимо, здесь ориентированный, иначе непонятно, чего от нас хотят. Тогда link это make\_root + обычный link. cut совсем обычный, make\_root тоже 
    из обычного link-cut. Осталось разобраться с предками. Что такое быть предком? Это если я вошёл в вершину v раньше u, а вышел позже. Осталось находить первое и последнее ребро, 
    где я вхожу и выхожу из вершины. Давайте хранить (на самом деле treap, но пока представим что это массив) массив рёбер, выходящих из вершины. Точнее, массив указателей на их 
    pNode. Массив будет отсортирован. make\_root будет выполнять циклический сдвиг этого массива, следовательно, когда мы захотим найти, какой же из элементов массива сейчас 
    лежит левее всего в ETT, мы сможем бинарить в таком массиве и спрашивать позицию в ETT (если у нас есть циклически сдвинутый отсорченный массив, то его наименьший элемент можно найти 
    за бинпоиск). Только запрос в ETT выполняется за лог, поэтому это $\log^2$ на поиск самого левого/правого вхождения вершины в ETT. Осталось заметить, что у нас есть link и 
    cut, поэтому надо будет вставлять/удалять рёбра в эти массивы, поэтому заменим эти массиры на treap. Теперь чтобы находить место, куда в них вставлять элемент, тоже нужен бинарь, поэтому 
    link будет тоже за $\log^2$, а cut и make\_root всё ещё за логарифм. \\
\end{enumerate}

\end{document}
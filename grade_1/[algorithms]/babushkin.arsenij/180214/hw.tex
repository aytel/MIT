\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 

\begin{document}
\def\t{\texttt}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item За $O(n + m)$ можно проверить, является ли a подпоследовательностью b $\to$ эта задача $\in$ P. \\
    \item Делаем бинпоиск по ответу. Затем пусть у нас есть n клозов, и мы хотим проверить, можно ли удовлетворить k из них. 
    Делаем схему сложения, где входы -- значения клозов, а выходов log n. Тогда k однозначно определяет, какие из этих log n должны 
    быть равны 1, то есть эти гейты надо выполнить. Запускаем CIRCUIT-SAT. \\
    \item Напишем на i-ом предмете число $m^i$, где m -- (число множеств $B_j + 1$). Весом множества будет сумма весов его элементов. Тогда 
    если множества покрывают U без пересечений, то их вес будет $= \sum_{i = 1}^n m^i$, а иначе не будет, потому что чтобы получить i-
    ую степень числа m, надо иметь m экземпляров $(i{-}1)$-й степени, а у нас их максимум m-1, т.к. множеств m-1. \\
    \item Решим VERTEX COVER через SET-COVER. Поставим каждой вершине в соответствие множество рёбер, которые она покрывает, и 
    решим SET-COVER. Успех.\\
    \textbf{Update:} Подсказка для deicsion-версии -- покрывающий набор множеств. \\
    \item Сведём SET-COVER к HITTING-SET. Поставим в соответствие каждому элементу множество множеств, в которых он лежит, а наши множества 
    сделаем элементами. Тогда если раньше элемент был в множестве, то теперь наоборот. Решим HITTING-SET. \\
    \textbf{Update:} Подсказка для deicsion-версии -- покрывающий набор элементов. \\
    \item Сведём HAMCYCLE к нашей задаче. Существующим рёбрам поставим вес 0, несуществующим -- 1. Если у минимального по весу 
    гамильтонова цикла вес 0, то он существует, иначе нет. \\
    Decision -- существует ли путь веса $\le$ W. Понятно, что она NP-hard (то же сведение HAMCYCLE к ней), осталось показать, что она в 
    NP. Подсказка -- сам путь $\to$ она в NP. \\
    \item ~\\
    \item 3-SAT $\in$ NP, но если ETH, то 3-SAT $\notin$ P. чтд. \\
\end{enumerate}

\section{Дополнительные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item ~\\
    1) PARTITION $\to$ JOB-SCHEDULING. У нас будет два рабочих, а заказ -- это предмет, и его время выполнения -- вес предмета. Минимизируем 
    время выполнения -- минимизируем разность между одним множеством и другим, если эта разность 0 -- успех. \\
    2) SUBSET-SUM $\to$ PARTITION. Пусть вся сумма весов -- S, а мы хотим найти подмножество веса W. Добавим предмет веса K = S-2*W. 
    Поскольку найти подмножество веса -- это то же самое, что найти подмножество веса S-W, мы можем выбрать W $\le$ S/2. Теперь сделаем 
    PARTITION. Выкинем предмет веса K оттуда, куда он попал. Тогда оставшееся множество будет веса W. Ура. \\
    \item ~\\
    \item Известный критерий, что p простое -- $\exists a: a^{p - 1} = 1 (mod~p),$ но $\forall q : q | (p - 1)$ и $q$ -- простое, 
    $a^{\frac{p - 1}{q}} \ne 1 (mod~p)$. Тогда подсказка -- это такое a и разложение числа p - 1 на простые множители. Дальше легко проверить 
    всё, что нужно, бинарным возведением в степень. Осталось проверить корректность подсказки, то есть проверить, правда ли данные нам числа 
    простые. Давайте рекурсивно запустим PRIME от них. Тогда пусть $k = \log p$. $T(k) = Poly(k) + T(x_1) + T(x_2) + ... + T(x_m)$, причём 
    $\sum x_i \le k - 1$, т.к. p - 1 чётное и, следовательно произведение всех нечётных множителей p - 1 хотя бы в два раза меньше p. Давайте 
    поверим, что такая рекурсивная формула задаёт нам полином от k. \\
\end{enumerate}

\end{document}
\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 

\begin{document}
\def\t{\texttt}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item Держим на отрезке gcd и пушим число, на которое домножили. Реальный gcd отрезка -- это его gcd \* его push. В итоге O($\log n$) раз 
    посчитаем gcd. Но вроде они все суммарно должны отработать за $\log A$. \\
    \item Вроде понятно, что если есть присвоение на отрезке и произведение, то присвоить на отрезке длины l x -- это значит присвоить произведению 
    значение $x^l$. Вопрос в том, как такое пушить. Заметим, что все отрезки у нас длины $2^k$, поэтому достаточно для каждого x предподсчитать его такие степени 
    и сохранить, а затем значение пуша брать из этих массивов. \\
    \item Держим в вершине ДО отсортированный массив значений из отрезка, за который эта вершина отвечает, причём с пропусками -- массив отсортирован по значению 
    элементов, а ещё мы хотим, чтобы индексы этих элементов в массиве возрастали слева направо. Например, если у нас в отрезке есть два элемента: 
    x на позиции i и y на позиции j, причём x > y и i < j, то элемент y нам никогда интересен в этой вершине не будет. Запрос в ДО будет выглядеть так: 
    выпишем все вершины, которые отвечают за отрезок [pos, n]. Пойдём по ним слева направо. Остановимся, когда найдём веришну, в которой будет хоть один 
    элемент $\ge$ x, это можно чекать за О(1) смотря на последний элемент массива. Сделаем в этой вершине бинпоиск. \\
    Так мы нашли ближайший больший x справа. Аналогично можно найти ближайший больший x слева и выбрать из них. \\
    \item ~\\
    \item ПСП == СП с нулевым балансом и неотрицательными префиксными балансами $\to$ нам нужно ДО, которое умеет в сумму на отрезке, изменение элемента 
    и минимум префиксных сумм на отрезке. С первыми двумя понятно, второе тоже просто хранить и обновлять: если у вершины v есть дети u и w, то min\_pref(v) = 
    min(min\_pref(u), min\_pref[w] + sum(u)). \\
    \item ~\\
    a) Пометим, когда из клетки i ушёл котик. Если не ушёл, то поставим бесконечность. Нас интересует для каждого отрезка, когда ушёл последний -- 
    максимум на отрезке. Решили за линию с ФКБ. \\
    b) ~\\
\end{enumerate}

\section{Дополнительные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item Сожмём координаты по y, пройдём окном шириной a слева направо. События -- "точка теперь попадает в прямоугольник", "точка теперь не попадает в прямоугольник". 
    Оба события -- += на отрезке, потому что если точка (x, y) теперь попадает, то давайте прибавим её вес отрезку [y - b, y] в ДО, а если не попадает -- вычтем. Значение элемента в ДО 
    в данный момент -- это какую сумму мы получим, если поставим правый нижний угол туда. На каждом шаге спрашиваем глобальный максимум в ДО. \\
    \item Бинпоиск по ответу, теперь у нас есть набор квадратов, в которые нельзя поставить центр нашего квадрата, и мы хотим проверить, есть ли точка, непокрытая этими квадратами. 
    Это сканлайн + ДО на += на отрезке и глобальный минимум. Итого $n \log^2 n$. \\
    \item ДО, где в вершине лежит отсорченный массив. На каждом таком массиве строим sparse table, чтобы узнавать gcd на отрезке за О(1). Осталось взять gcd логарифма величин, 
    но, как и в первой задаче обязательной части, они должны отработать суммарно $\log A$. \\
\end{enumerate}

\end{document}
\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 

\begin{document}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item $\sum\frac{k^2}{2^k} = S_0, \sum\frac{2k+1}{2^k} = S_1, \sum\frac{1}{2^k} = S_2 = 1$. Тогда $S_0 = S_1 + S_0/2, S_1 = S_2 + S_2/2 + S_1/2 \to S_1 = 3S2 \to S_0 = 6S_2 = 6$. \\
	\item Среднее на отрезке $ = \frac{\sum a[i]}{r - l + 1} \le \frac{a_{max} * (r - l + 1)}{r - l + 1} = a_{max} \to$ отрезок с макс. средним -- это отрезок из одного элемента, содержащий в себе максимальный элемент всего массива. Давайте найдём максимум в массиве за $O(n)$. \\
	\item Переберём правый конец отрезка, держа в хеш-таблице $cn$, сколько в текущем отрезке каждого элемента. Когда мы пришли в позицию i, давайте двигать левый конец текущего отрезка вправо, пока такое движение оставляет в хеш-таблице хотя бы k элементов j таких, что $cn[j] > 0$. Обновим ответ. \\
	\item Переберём правую границу нашего отрезка, поддерживая ещё два указателя -- l и r. Пусть наша позиция j. Тогда указатель l такой, что (j - l + 1) $\ge$ L и в [l..j] хотя бы А различных чисел, а среди всех таких самый правый. Аналогично r такой, что (j - r + 1) $\le$ R и в [r..j] не больше В различных чисел, а среди таких самый левый. Понятно, что оба указателя двигаются только вправо и легко поддерживать их с помощью хеш-таблицы как в предыдущем задании. Если r > l, то сейчас всё плохо, иначе можно обновить ответ с помощью pr[j] - min(pr[i]), i $\in$ [r..l], где pr -- массив префиксных сумм. min(pr[i]) поддерживаем с помощью минимума на очереди, префсуммы предподсчитаем заранее. Успех. \\
	\item Если мы хотим максимизироват число, то надо сначала максимизировать его длину, а потом лексикографически. Тогда, очевидно, мы хотим выбрать лексикографически максимальную подстроку длины $n-k$. Заметим, что первая цифра лежит на отрезке [0..k - 1], иначе нам вообще не хватит цифр. Тогда давайте выберем максимальную на этом отрезке цифру, а среди таких самую левую. Пусть она стоит на позиции i. Тогда следующую будем искать на отрезке [i+1..k], найдём j, затем на отрезке [j..k+1], и т.д.. Это работает, потому что для лекс. максимизации надо жадно максимизировать элементы начиная с самых первых. \\
Это работает за линию, потому что нам надо всего лишь держать максимум на очереди. \\
И это работает для любого d. \\
	\item Пусть pr[i] = j, если [j..i] -- ПСП и j самая левая среди всех подходящих. Если таких нет, то pr[i] = -1. Давайте научимся считать этот массив. Будем держать стек открывающих скобок. Если приходит новая открывающая, то мы добавляем её в стек и pr[i] = -1. Если закрывающая, то два варианта: \\
1) Она НЕ такого же типа, как и открывающая на вершине стека. Тогда, очевидно, для неё нет подходящей парной открывающей и вообще всё плохо -- ни одна ПСП не включает в себя эту скобку. Снимаем все открывающие со стека и начинаем с чистого листа, а pr[i] = -1.
2) Она такого же типа, как верхняя на стеке. Пусть эта верхняя была на позиции j. Тогда [j..i] -- ПСП. Посмотрим pr[j - 1]. Если pr[j - 1] = -1, то pr[i] = j, иначе pr[i] = pr[j - 1], то есть мы конкатенируем ПСП, которая закончилась в j - 1 и ПСП [j..i]. Работает за линию, потому что на каждом шаге $O(1)$ действий. Успех. \\
\end{enumerate}

\section{Дополнительные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item Давайте для каждой клетки посчитаем столбец только из нулей вверх от неё. Если в ней стоит 1, то этот столбец = 0, иначе столбец = (такой же столбец для клетки сверху) + 1. Теперь переберём строку, в которой будет находиться правая нижняя клетка нашего нулевого прямоугольника. Создадим стек пар < int, int >, где первое число в паре будет высотой столбца, а второе -- количеством столбцов такой высоты, идущих подряд. Изначально стек пустой. \\
Переберём клетку в строке. Пусть мы пришли в клетку, у которой столбец вверх = k. Тогда понятно, что любой нулевой прямоугольник, в котором эта клетка должна быть правой нижней, не может быть выше k. Будем снимать со стека пары до тех пор, пока первое число в них больше k, и заменять их на такие, в которых оно = k. То есть если стек был \{(1, 1), (3, 3), (5, 1)\} и k = 2, то мы снимем с него (3, 3) и (5, 1), и положим обратно (2, 4), т.к. три столбика по три и один по пять превратились в четыре по два. Затем положим наш текущий столбик. Стек будет \{(1, 1), (2, 5)\}. \\
Зачем всё это нужно? \\
Давайте попробуем посчитать для каждого столбца слева от нас, сколько в нём способов выбрать клетку так, чтобы она стала левой верхней в нашем прямоугольнике и он был корректным. Понятно, что если в i-ой слева клетке столбец вверх = j, то мы не сможем выбрать прямоугольник высотой больше, чем минимум из высот столбцов на отрезке [i..cur], где cur -- моя текущая клетка, ведь когда мы выбираем прямоугольник, то мы выбираем несколько столбцов одинаковой высоты, каждый из которых обязан не содержать единиц. То есть для каждого столбца слева от нас мы хотим поддерживать минимум из высот столбцов между ним и нашей текущей клеткой. Описанный выше стек именно это и делает, только при эттом сжимает одинаковый ответ для подряд идущих столбцов для скорости работы. Ответ для нашей текущей клетки -- это просто сумма i.first * i.second по всем парам i, лежащим в стеке. Такую сумму легко поддерживать, изменяя стек. \\
Просуммируем ответ по всем клеткам. Это и будет то, что нам нужно.
\end{enumerate}

\end{document}

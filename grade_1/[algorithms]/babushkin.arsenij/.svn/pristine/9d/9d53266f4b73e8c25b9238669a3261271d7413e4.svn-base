\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 

\begin{document}
\def\t{\texttt}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item dp[i] -- мин. число кубов чтобы разложить число i. Пришли в i, перебрали x, обновили dp[i] через 
    dp[i - x * x * x] + 1. x * x * x <= n, итого O($n^{4 / 3}$). \\
    \item Выберем произвольную вершину, запустим от неё дфс, насчитаем размеры поддеревьев. Запустим второй дфс, 
	поддерживая во время обхода рамер "наддерева" вершины, то есть до скольки вершин путь лежит через её отца. 
	Теперь просто для каждой вершины проверим, что размер всех её поддеревьев и наддерева не больше 2n/3, и если так, 
	то добавим её в ответ. \\
	\item Давайте скажем, что мы можем занулить весь массив и ответ не станет хуже. Возьмём нулевой элемент и выберем: 
	получали мы профит, когда зануляли его, или нет. Если да, то это значит, что его соседей мы не троагил до того, 
	как занулили его -- тогда можно сказать, что его мы занулили первым, а затем сделать линейную дп. 
	Аналогично если мы не получали за него профита, то кто-то из его соседей уже был занулён -- давайте выберем, кто, 
	и снова сделаем линейную дп. \\
	Как делать дп? Пусть мы обрабатываем префикс i. Тогда мы могли или занулить элементы от i - 2 до i, и dp[i] = 
	zero(i - 1) + dp[i - 3], или нет, и тогда dp[i] = dp[i - 1]. \\
	\item Если имелось в виду "нестрого выше" и "нестрого ниже", то можно оставить НВП дубов, а все остальные убить, и 
	это наилучший ответ, а если нет, то не умею :( \\
	\item 2^n. Пусть в нашей строке s есть x открывающих и y закрывающих. Тогда строка [y * '('] + s + [x * ')'] 
	правильная. \\
	\item Посчитаем dp[i][j] -- сколько есть последовательностей из i цифр с суммой цифр j. j <= 9 * i, поэтому всего 
	полей n * n * 10, а переходов из каждого состояния 10 -- по каждой цифре k из dp[i][j] в dp[i + 1][j + k]. \\
	В конце надо пройти по всем суммам s и прибавить dp[n][s] * dp[n][s] к ответу. \\
	А ещё можно ускорить это решение, если заметить, что если считать дп назад, а не вперёд, то все переходы из 
	dp[i - 1][j - k] в dp[i][j] -- это какой-то суффикс массива dp[i], то есть можно их считать за О(1) суфф. суммами. \\
	\item Раз разбиения неупорядоченные, то давайте их упорядочим по возрастанию чисел, на которые бьём. 
	dp[i][j][k] -- кол-во способов разбить число i на j слагаемых, чтобы последним было k. 
	dp[i][j][k] = dp[i][j][k + 1] + dp[i - k][j - 1][k], то есть мы или увеличили последнее число на 1, или поставили его 
	в последовательность и перешли дальше. \\
\end{enumerate}

\section{Дополнительные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item
\end{enumerate}

\end{document}
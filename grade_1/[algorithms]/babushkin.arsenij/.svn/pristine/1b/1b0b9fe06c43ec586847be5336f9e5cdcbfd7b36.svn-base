\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip}

\begin{document}
\def\t{\texttt}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item ~\\
	a) Нашли медиану, сделали массив из элементов \t{|pos(x) - pos(median)|}, нашли там $k$-ую порядковую, выписали все элементы, которые меньше этой $k$-ой. \\
	b) Нашли медиану, сделали массив из элементов \t{|x - median|}, нашли там $k$-ую порядковую, выписали все элементы, которые меньше этой $k$-ой. \\
	\item ~\\
	a) $f = \sum_i(w_i(x_i - x^*)^2), f' = 0$ при $x^* = \frac{w_ix_i}{n}, O(n)$. \\
	b) По каждой из осей можно решать независимо, то есть у нас есть задача $\sum_i(w_i|x_i - x^*|) \to min$, а это просто найти взвешенную медиану, $O(n)$. \\
	c) Повернём на $\frac{\pi}{4}$, теперь вместро суммы $|x_i - x^*| + |y_i + y^*|$ у нас $max(|x_i - x^*|, |y_i - y^*|) \to$ ответ на задачу -- максимум из максимумов, то есть снова независмые задачи по каждой из координат. Надо решить задачу $max_i(w_i|x_i - x^*|) \to min$. Это можно представить как отрезки, расширяющиеся со скоростью $w_i$, и нам надо найти первый момент времени, когда их пересечение непусто. Давайте посмотрим, где будет находиться самая левая из правых границ отрезков в каждый момент времени. Это возврастающая функция и она кусочно-линейная, её можно построить за $O(sort + n)$, отсортировав точки по $w_i$ и построив пересечение полуплоскостей. Аналогично строим для самой правой из левых границ. Нам нужен момент времени, когда самая правая из левых $\ge$ самой левой из правых $\to$ надо найти, где две кусочно-линейные функции пересекаются, это делается двумя указателями. Итого $O(sort + n)$. \\
	\item Отсортируем массив. Теперь если мы поставим две точки куда-то, то одна будет отвечать за некоторый префикс этого массива, а другая -- за оставшийся суффикс. Пусть мы решили, за какой префикс должна отвечать первая точка. Тогда нам надо её поставить во взвешенную медиану этого префикса, а вторую -- во взвешенную медиану оставшегося суффикса. Если мы будем перебирать этот предполагаемый префикс слева направо, то эти медианы можно поддерживать, как и суммы $\to$ можно решить за $O(sort + n)$ с помощью трёх указателей. \\
	\item ~\\
	\item ~\\
	a) $T(n) = \Theta(n) + T(\frac{n}{7}) + T(\frac{3n}{4}), \frac{1}{7} + \frac{3}{4} < 1 \to T(n) = \Theta(n)$ \\
	b) $T(n) = \Theta(n) + T(\frac{n}{3}) + T(\frac{3n}{4}), \frac{1}{3} + \frac{3}{4} > 1 \to T(n) = \Theta(\alpha^n), \alpha > 1$
\end{enumerate}

\section{Дополнительные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item При фиксированном $y^*$ и движении $x^*$ слева направо функция будет выпуклой вниз, и то же самое для $y^*$ $\to$ давайте сделаем два вложенных тернарных поиска. \\
	\item Пусть \t{p[i][j]} -- позиция, куда лучше всего поставить последнюю точку, если мы хотим оптимально разбить префикс длины \t{i} с помощью \t{j} точек. Заметим, что \t{dp[i][j]} $\le$ \t{dp[i + 1][j]} $\to$ можно сделать Divide-and-conquer, пересчитывая p по слоям (разбить с помощью j точек -- это выбрать последнюю и потом разбить оставшийся префикс с помощью j - 1 точки), решение за $O(nk\log n) = O(n\log n)$ в нашем случае. \\
	\item Давайте научимся делать merge двух куч за $O(h)$, где h -- высота максимальной из них. Как это сделать? Пусть корень первой кучи < корня второй. Тогда сделаем его корнем новой кучи, вторую кучу подвесим к нему слева, а справа подвесим merge его детей. Тогда $T(h) = 1 + T(h - 1) = \Theta(h)$. Теперь давайте хранить две кучи -- основную и дополнительную, размера $\log n$. Add делаем во вторую за $O(\log\log n)$. Когда она становится больше $\log n$, мёржим её с первой за $\Theta(\log n)$, таких операций будет сделано не больше $\frac{n}{\log n} \to$ суммарно они работают за $\Theta(n)$. Когда мы извлекаем элемент, то просто хотим извлечь минимальный из двух куч. Таким образом, Add работает за $O(\log\log n)$, а асимптотика других функций не испортилась. Успех.
\end{enumerate}

\end{document}
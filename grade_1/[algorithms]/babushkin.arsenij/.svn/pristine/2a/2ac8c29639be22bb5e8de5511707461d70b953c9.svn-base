\documentclass[12pt]{article} 

    \usepackage{cmap} 
    \usepackage[T2A]{fontenc}
    \usepackage[russian,english]{babel}
    \usepackage[utf8]{inputenc} 
    \usepackage{amsmath, amssymb} 
    
    \usepackage{hologo} 
    \usepackage[russian]{hyperref} 
    
    \textwidth=160mm
    \hoffset=-15mm
    \textheight=240mm
    \voffset=-20mm
    
    \newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 
    
    \begin{document}
    \def\t{\texttt}
    
    Бабушкин А.
    
    \section{Обязательные задачи}
    
    \begin{enumerate}
        \setlength{\parskip}{0pt} 
        \setlength{\itemsep}{0pt} 
        \item ~\\
        a) Как в практике, но пускаем из каждой вершины Дейкстру, а не бфс. \\
        b) Пусть мы хотим найти гамильтонов цикл в графе. Назначим всем рёбрам в нём вес -1 и решим нашу задачу. Тогда если через вершину 
        проходит цикл веса n, то гамильтонов цикл есть. То есть мы свели hamcycle к нашей, то есть она NPh. \\
        \item Ребро a $\to$ b, стало веса w. Для всех пар вершин i, j обновим d[i][j] min= d[i][a] + w + d[b][j]. \\
        \item По индукции. Для одной вершины $x_0$ это правда. Почему мы максимизируем значение для вершины, взятой на k-ом шаге? 
        Потому что мы Дейкстрой выберем самое строгое их ограничений на значение этой вершины и реализуем его, то есть больше никак нельзя. 
        Но если мы максимизируем каждую вершину в отдельности, то и сумму тоже. \\
        \item Полный (и с петлями тоже) граф на n вершинах, где все рёбра имеют вес $-1$. Если мы бдует делать Флойда не в одной табличке, 
        а на каждой итерации заводя новую, то на k-ой у нас будут значения $-2^k$, а когда мы делаем Флойда без создания новых массивов, 
        то наш результат никогда не хуже, чем с созданием их. \\
        \item ~\\
        a) Пусть X -- минимальный вес среди этих отрицательных рёбер. Вычтем из всех рёбер вообще X, найдём путь, прибавим к его весу 2X. 
        Всё хорошо, потому что оптимальный путь содержит ровно два ребра из таких: одно около s и одно около t (исключая случай, когда путь 
        из одного ребра -- обработаем отдельно, и ещё случай, когда есть отрицательный цикл, содержащий а -- тоже отдельно, тогда ответа нет). 
        b) Переберём случаи -- или вершина x не участвует в пути, тогда выкинем её из графа и как в прошлом пункте, или участвует, и тогда 
        найдём пути s $\to$ x и x $\to$ t как в прошлом пункте. \\
        \item Пусть есть отрицательное ребро. Тогда надо полечить или первую вершину, или вторую. Тогда по условию у нас есть две вершины, 
        которые покрывают все отрицательные рёбра. Переберём одну вершину и тип лечения: увеличим её мы или уменьшим. Когда мы это перебрали, 
        то выкинем из рассмотрения все рёбра, которые мы так порадуем (если мы себя увеличиваем, то мы радуем все исходящие, и наоборот). 
        Тогда все оставшиеся рёбра должны иметь одну общую вершину одного типа (то есть все или выходят из одной, или входят в одну). 
        Как проверить, что это правда? Давайте поддерживать hashtable: in[v] == количество неудовлетворённых рёбер, которые идут в v, 
        out[v] аналогично. Их легко поддерживать. Тогда после перебора вершины давайте посмотрим, что у хоть одной из хэш-таблиц размер 1 
        (нулевые элементы удаляем). Успех. \\
    \end{enumerate}
    
    \section{Дополнительные задачи}
    
    \begin{enumerate}
        \setlength{\parskip}{0pt} 
        \setlength{\itemsep}{0pt} 
        \item $VE\log$: бинпоиск по ответу, затем у нас есть известная задача про неравенства ($x_i - x_j \le d_{ij}$) с отрицательными рёбрами, 
        давайте проверим, что нет отрицательного цикла Фордом-Беллманом. \\
    \end{enumerate}
    
    \end{document}
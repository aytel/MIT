\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 

\begin{document}
\def\t{\texttt}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
    \setlength{\parskip}{0pt} 
    \setlength{\itemsep}{0pt} 
    \item Заметим, что это те же самые коробки, где вес коробки -- время выполнения задачи, а сколько она может выдержать -- дедлайн. 
    Обе задачи мы умеем для коробок решать на $n\log n$.
    \item ~\\
    \item ~\\
    \item Найдём центроиду. Теперь все поддеревья относительно неё надо разбить на две кучки -- это будет первое поддерево и второе. \\
    Размер каждого из них должен быть от $\frac{n}{3}$ до $\frac{2n}{3}$. Если хотя бы одно дерево имеет размер хотя бы $\frac{n}{3}$, то 
    возьмём его (оно меньше $\frac{n}{2} \to$ меньше $\frac{2n}{3}$), а все остальные в другую кучку. Если такого нет, то берём все по очереди 
    и добавляем -- мы никогда не проскочим промежуток размера $\frac{n}{3}$. \\
    \item Держим dp[i] = максимальный авторитет, который можно получить, имея ровно i людей. Сортируем их по сумме a и b (по тем же соображениям, 
    что и в коробках). Перебираем в таком порядке, внутри идём циклом по dp и релаксируем, если dp[i] $\le$ a, то dp[i + 1] max= dp[i] + b. \\
    Изначально dp[0] = A, dp[i] = INF, если i $\ne$ 0. В конце смотрим на максимальное i, где dp[i] $\ne$ INF. \\ В первом пункте просто достаточно проверить, 
    можно ли взять всех. \\
    \item А это предыдущая задача, с той разницей что A = 0 и отрицательные авторитеты нам получать нельзя. Ну тогда просто запретим релаксироваться, если 
    результат меньше 0. В данной задача изменение авторитета равно разности открывающих и закрывающих скобок (балансу), а минимальное требование -- 
    max(0, min баланс префикса)). \\
\end{enumerate}

\section{Дополнительные задачи}

\begin{enumerate}
    \setlength{\parskip}{0pt} 
    \setlength{\itemsep}{0pt} 
    \item Отсортируем задачи по убыванию $\frac{fee}{t}$ и возьмём первую. Если это корень, то она неинтересная, всё равно её выучим первой -- идём дальше. 
    Утверждение: есть оптимальный ответ, где эта задача будет идти сразу после своего предка. Почему? Пусть нет. Это задача v, предок p, 
    а перед v мы выучили m. Поменяем местами v и m. Ответ улучшится. Почему мы можем так сделать? Мы не можем поменять их местами, если m 
    предок v. Но если m предок v, а отец v -- p, то m предок p тоже. Тогда m не могло стоять в ответе после p. Ура. \\
    Как теперь решить задачу? Будем держать кучу вершин и склеивать их СНМом. Взяли самую толстую, смёржили её с отцом. Их fee и t сложатся, 
    плюс к ответу добавится какая-то константа. Делаем так до тех пор, пока не останется одна вершина. \\
    
\end{enumerate}

\end{document}
\documentclass[12pt]{article} 

\usepackage{cmap} 
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{amsmath, amssymb} 

\usepackage{hologo} 
\usepackage[russian]{hyperref} 

\textwidth=160mm
\hoffset=-15mm
\textheight=240mm
\voffset=-20mm

\newcommand{\Section}[1]{\section{#1}\vspace{-1.5em}\hspace*{\parindent}\unskip} 

\begin{document}
\def\t{\texttt}

Бабушкин А.

\section{Обязательные задачи}

\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item Построим двоичные подъёмы только на вершинах, глубина которых делится на округлённый вверх $\log n$. Теперь когда ищем lca сначала поднимаемся от v 
    глупо до ближайшей такой вершины, от неё скачем двоичными подъёмами до самой верхней, которая не предок u, и там снова глупо поднимаемся. Каждая фаза работает 
    за лог. \\
    \item Если вершины в одной компоненте рёберной двусвязности, то мы не можем не пройти только по ним самим, иначе нас интересует путь по таким компонентам между ними. 
    За dfs находим компоненты, на дереве этих компонент строим что-нибудь для поиска lca. \\
    \item ~\\
    \item dp[k][v] -- min сумма последовательности из k элементов с концом в элементе v. Пересчитать dp[k][v] -- взять минимум на отрезке dp[k - 1]. Можно rmq, а 
    можно держать минимум на очереди и получить халявный O(nL). \\
    \item ~\\
    a) Будем в ДД держать эйлеров обход дерева, причём для каждой вершины две копии -- как будто если бы мы делали push\_back в вектор когда входили в вершину и 
    когда выходили. Тогда между первым и вторым вхождением у нас как раз поддерево. Добавить лист -- это вставить две новые вершинки в правильно место в ДД. \\
    b) Выпишем сразу эйлеров обход для итогового дерева, запихнём его в ДО, изначально заполненное нулями, и будут запросы "сделать элемент единичкой" и "сумма на отрезке". \\
\end{enumerate}

\section{Дополнительные задачи}
\begin{enumerate}
	\setlength{\parskip}{0pt} 
	\setlength{\itemsep}{0pt} 
	\item
\end{enumerate}

\end{document}